# Locality Consolidation Algorithm

// TODO: Handle adjacencies not reporting to lowest geographic rank. Normally when comparing the localities of regions, every locality designated with one region is potentially compared with every locality designated with the other region. But if the adjacency engine does not report the adjacency of lowest-ranked localities, localities designated with those regions will be left out of the comparison. Hence, when comparing with a region pulled in via adjacency, if that adjacency is marked as the lowest-rank provided adjacency and it is not a county, then the comparison needs to include all localities contained within the region, even those of lower ranks. (So it seems that I need to attach a boolean to regions indicating: region was pulled in via adjacency AND region is the lowest rank available via adjacency AND the region rank is not county. But do I need to track whether it was pulled in via adjacency?) This seems like a question of which localities to pull in upon comparing regions.

// TODO: Support localities/regions pulled in via CSV or via single newly added record. When importing a CSV or entering a single new record, the domain is the set of region in the CSV or the region in the new record. And when processing an domain region, each locality of the CSV (or the new locality) is compared against the localities of the adjoining regions (including the region itself). When processing a non-domain region, each locality of the non-domain region is compared only to localities in the CSV or the locality of the new record.

## Important Notes

(+) Because multiple users on the same computer or across multiple computers could be simultaneously doing consolidations, I'll need to verify that associated data in Specify has not changed prior to modifying the database.

## Terminology

(+) Domain: The set of all geographic regions whose localities are all to be examined for consolidation with other localities, whether these other localities belong to regions within the domain or not. For any region that contains a region in the domain, the containing region is also in the domain.

(+) Over Domain: The set of all geographic regions each containing at least one region of the domain but not itself in the domain.

(+) Word delimiter: any of the characters (".:;/!&()+-=[]{}?<>|\), plus em dash and en dash, plus the comma if not immediately adjacent to two digits, plus the single quote if not immediately adjacent to two alphabetic (non-numeric, non-punctuation) characters, plus CR or LF, plus the start or end of a string. Dashes are intentionally word delimiters so that occurrences with and without dashes can be found equivalent.

(+) Word: A sequence of one more characters either beginning with an alphabetic character or else containing only digits (representing an integer), and bounded on each side within text by a word delimiter.

(+) Normalized word: A word latinized by removing all accents and diacritics, by converting to lowercase, and by deleting single quotes.

(+) Word series: A set of one or more consecutive words found in text excluding words of fewer than 3 characters and other specific words, normalized and then alphanumerically ordered. Words of fewer than 3 characters are ignored for purposes of determining whether words are consecutive, as are the following words: and, for, from, the, with.

(+) Phonetic code: The phonetic code of a word containing no digits is the phonetic encoding of the word, according to some phonetic encoding algorithm. The phonetic code of a word containing at least one digit is the exact word itself, preceded by a pound ('#'), assuming that the pound does not appear in any phonetic encoding. The phonetic code for any other word that the phonetic encoding algorithm cannot code is also the exact word preceded by a pound.

(+) Phonetic series: A set of one or more phonetic codes together corresponding to a word series, with each phonetic code being the phonetic code for its corresponding (normalized) word in the word series, ordered alphanumerically by phonetic code.

(+) Locality key: A storage key that is a hybrid of the ID for the most-specific geographic region associated with the locality and the locality ID.

## Persistent Data Structures

### AdjacentRegionsGraph

Indicates which geographic regions touch one another, associating regions by their Specify geographic IDs. This data structure could be kept in memory once read from storage, because it's not very large. In particular, this structure indicates:

(+) Adjacencies among U.S. counties.
(+) Adjacencies among U.S. counties and Mexican states.
(+) Adjacencies among U.S. counties and Canadian provinces.
(+) Adjacencies among U.S. states, Mexican states, and Canadian provinces.
(+) Adjacencies among North American countries.

The relationships that Specify provides also make it possible to navigate from county to state and from state or province to country. Each containing region is treated as adjacent to each of the regions it contains (and vice versa). And each region is considered adjacent to each region that contains an adjacent region (and vice versa).

For the remainder of this document, regions are considered "adjacent" when they are adjacent according to AdjacentRegionsGraph.

### RegionRoster

A list of the regions undergoing consolidation, serving as a to-do list for the consolidation algorithm. Regions are added to the region roster during consolidation but not removed until consolidation completes, so that the algorithm has access to the consolidation status of all regions found relevant.

The key is the region's geography ID. The value is a structure containing the following information:

(+) rank: The region's geographic rank (in Specify)
(+) inDomain: Whether the region is in the domain
(+) localityTotal: The number of localities that point to the region as the most-specific region for the locality. The implementation could compute this on-demand and save computed values for reuse later. If includesLowerRanks is true, add to this number the number of localities in all regions contained within the present region.
(+) status: "pending" indicates that its localities must be examined but haven't been cached yet; "cached" indicates that the localities have been cached but not examined yet; "complete" indicates that the localities have been examined and their caches removed. Initialized to "pending".
(+) adjoiningPendingCount: The total number of localities remaining to be cached in all adjacent regions. This value is initialized to zero but only meaningful in cached regions.
(+) includesLowerRanks: Whether the region not only represents localities designated with this region, but also all localities designated with lower-ranked regions that the region contains. Needed to support adjacencies that aren't given at the lowest possible rank.

RegionRoster is initialized to the regions of the domain, including all regions contained within regions of the domain. Regions adjacent to those in the domain are added to the region roster as needed.

Define function cacheRegion(region to cache (C)):
	(+) For each locality (L1) in localitiesOfRegion(C, C.includesLowerRanks):
		(+) Cache (L1) in LocalityCache.
		(+) Update PhoneticLocalityIndex for (L1)'s phonetic codes.
	(+) Mark (C) as cached in RegionRoster.
	(+) If (C) is in the domain:
		(+) For each region (A) in the set containing regions strictly adjacent to (C), regions containing (C), and regions contained in (C):
			(+) If (A) is not in RegionRoster:
				(+) Add (A) to RegionRoster with status "pending".
			(+) If (A) has status "pending":
				(+) Add (A)'s localityTotal to (C)'s adjoiningPendingCount.
	(+) Else:
		(+) For each region (A) strictly adjacent to (C):
			(+) If (A) is in the domain and has status "pending":
				(+) Add (A)'s localityTotal to (C)'s adjoiningPendingCount.
		(+) If (C) is in the over domain:
			(+) For each region (A) contained in (C):
				(+) If (A) is in the domain and has status "pending":
					(+) Add (A)'s localityTotal to (C)'s adjoiningPendingCount.

### LocalityCache

Cached preprocessed localities. Prior to use, localities must be preprocessed to produce their word series and phonetic series. This is a time-consuming process, so the results are cached to prevent having to repeat the process. The algorithm manages this structure to try to minimize the number of localities that are cached at any time, thereby reducing the amount of memory required.

The key is a locality key, allowing localities to be looked up or deleted as a group by specific geographic ID, and allowing individual localities to be retrieved. The value is the preprocessed locality (details TBD).

### PhoneticLocalityIndex (Y)

Associates phonetic codes with cached localities whose phonetically-encoded text contains at least one instance of the phonetic code. Used to process groups of localities all sharing phonetic codes for possible presentation to the user to consider for consolidation.

They key is a phonetic code. The value is a list of locality keys.

When a cached locality is removed from the LocalityCache, its locality keys are removed from all of its phonetic codes in PhoneticLocalityIndex. When a phonetic key loses all of its associated locality keys, the record is removed from PhoneticLocalityIndex, thus keeping the size of PhoneticLocalityIndex to the minimum needed.

### ExcludedMatchesStore (X)

Stores permanent knowledge about which pairs of word series having identical phonetic series are not to be considered suggestive of having duplicate localities.

The key is a word series. The value is a list of word series, possibly empty. If the key is found in two different localities, their common phonetic series will not be considered a match for purposes of presenting a potential duplicate to the user. Similarly, if the key is found in one locality and one of its value word series is found in another locality, their common phonetic series will not be considered a match for purposes of presenting a potential duplicate to the user.

Each value of each key K also appears as a key in ExcludedMatchesStore indicating that it is not a match for the word series given by key K.

A word series is said to be paired with another word series in ExcludedMatchesStore if using one word series as a key yields a value containing the other word series.

## Storage Files

### LocalitySmarts

This is a data storage file stored in a preference-indicated directory and containing the following structures:

(+) CompletedAdjacenciesStore (X)

All users share this file.

### LocalityWork

This is a data storage file having a separate version stored in each user's directory and containing the following structures:

(+) LocalityCache
(+) RegionRoster
(+) RegionStatuses
(+) PhoneticLocalityIndex (Y)

The file also indicates the domain selected for consolidation.

The file is deleted after consolidation completes.

## Initialization for the Consolidation Algorithm

(+) If the user's LocalityWork file does not yet exist:

	(+) Create the LocalityWork file and its data structures.
	(+) Add each geographic region of the selected domain to RegionRoster, including all regions contained within regions of the domain.
	(+) Set the current region (R) to an arbitrary region of RegionRoster, selected from among the most specific regions available.
	(+) Call RegionStatuses.cacheRegion(R).
	
(+) If the user's LocalityWork already exists:

	(+) Set (R) to an arbitrarily selected cached region of RegionRoster having the lowest candidate value of adjoiningPendingCount.

## Outer Processing Loop

Select each next region to process in a way that minimizes the number of localities cached at any time while still allowing the user to evaluate one locality at a time before forever moving on to other localities.

Processes the current region (R), which must be a cached region of RegionRoster.

(+) Consolidate and remove (R) as follows:
	(+) If (R)'s adjoiningPendingCount is not zero:
		(+) If (R) is in the domain:
			(+) For each region (U) in the set containing regions strictly adjacent to (R), regions containing (R), and regions contained in (R):
				(+) If (U) has status "pending":
					(+) Call RegionStatuses.cacheRegion(U).
					(+) If (U) is in the domain:
						(+) For each cached region (A) in the set containing regions strictly adjacent to (U), regions containing (U), and regions contained in (U):
							(+) Subtract (U)'s localityTotal from (A)'s adjoiningPendingCount.
					(+) Else:
						(+) For each cached region (A) strictly adjacent to (U):
							(+) If (A) is in the domain:
								(+) Subtract (U)'s localityTotal from (A)'s adjoiningPendingCount.
						(+) If (U) is in the over domain:
							(+) For each cached region (A) contained in (U):
								(+) If (A) is in the domain:
									(+) Subtract (U)'s localityTotal from (A)'s adjoiningPendingCount.
		(+) Else:
			(+) For each region (U) strictly adjacent to (R):
				(+) If (U) is in the domain and has status "pending":
					(+) Call RegionStatuses.cacheRegion(U).
					(+) For each cached region (A) in the set containing regions strictly adjacent to (U), regions containing (U), and regions contained in (U):
						(+) Subtract (U)'s localityTotal from (A)'s adjoiningPendingCount.
			(+) If (R) is in the over domain:
				(+) For each region (U) contained in (R):
					(+) If (U) is in the domain and has status "pending":
						(+) Call RegionStatuses.cacheRegion(U).
						(+) For each cached region (A) in the set containing regions strictly adjacent to (U), regions containing (U), and regions contained in (U):
							(+) Subtract (U)'s localityTotal from (A)'s adjoiningPendingCount.
	[Note: At this point, there are no pending regions adjacent to (R).]
	(+) Process (R) according to the region consolidation algorithm.
	(+) Mark (R) as complete in RegionRoster.

(+) Select the next region to consolidate as follows:
	(+) If RegionRoster contains at least one cached region:
		(+) Set (R) to an arbitrarily selected cached region of RegionRoster having the lowest candidate value of adjoiningPendingCount.
	(+) Else:
		(+) Set (R) to end the loop.

(+) Repeat the loop if (R) is not null.

[Note: There is a solution that keeps even fewer localities cached at a time, but it jumps around from region to region, preventing the user from focusing on evaluating one locality against all possible similar localities before moving on to the next locality. The present approach should help the user be more efficient, less error-prone, and less frustrated.]

## Consolidate a Region

// TODO: Explore more efficient alternatives than iterating over phonetic codes in (L1). Can I better take advantage of adjacency?

Process the region (R), which must be a cached region.

(+) For each locality (L1) in localitiesOfRegion(R, R.includesLowerRanks):
	(+) For each phonetic code (P) in (L1):
		(+) For each locality (L2) associated with (P) in PhoneticLocalityIndex:
			(+) If (L2)'s region is adjacent to (R)*:
				(+) If at least one word series (W1) in (L1) has a phonetic series identical to a word series (W2) in (L2) such that (W1) is not paired with (W2) in ExcludedMatchesStore:
					(+) Ask the user whether (L1) represents the same locality as (L2).
						(+) If the user answers "yes":
							(+) Have the user to select one of the localities.
							(+) Give the user a chance to edit the selected locality.
							(+) If (L1) and (L2) are both in the DB, merge them as the newly selected/edited locality.
							(+) If (L1) or (L2) is in the CSV, either update the DB or the CSV, as required.
						(+) If the user answers "no":
							(+) Add all pairs of word series from (L1) and (L2) having identical phonetic series to ExcludedMatchesStore, where not already in ExcludedMatchesStore.
	(+) Remove (L1)'s contribution to PhoneticLocalityIndex.
	(+) Remove (L1) from LocalityCache.

* This could probably be made efficient by keeping a list of string representations of the geographic IDs adjacent to (R) and first looking up the geographic ID in PhoneticLocalityIndex's lookup key for (L2) in this list.

Define function localitiesOfRegion(cached region R, includesLowerRanks):
	(+) Let L be the set of localities assigned to region R.
	(+) If includesLowerRanks:
		(+) For each region S immediately contained in R:
			(+) Add localitiesOfRegion(S, true) to L.
	(+) Return L.

NOTE: I'll need to experiment with phonetic algorithms. I'll do this by running the program on different algorithms. But this may require faking locality mergers so that I'm not correcting the database and preventing myself from running the same experiment with another algorithm. I'm punting on how to handle algorithms until then.

NOTE: This algorithm assumes geographic IDs are correct but that coordinates could be incorrect. Another tool or another pass might present localities at similar coordinates for possible merger. For this reason, the merger code needs to be shared between activities.

NOTE: When displaying localities for comparison and then for merger, I need to display geography and coordinates too to help the user make a decision; and then the user may need to update geography, coordinates, or locality text.

break 4:20pm - 4:50pm

