# Locality Consolidation Algorithm

## Important Notes

(+) Because multiple users on the same computer or across multiple computers could be simultaneously doing consolidations, I'll need to verify that associated data in Specify has not changed prior to modifying the database.

## Terminology

(+) Domain: The set of all geographic regions whose localities are all to be examined for consolidation with other localities, whether these other localities belong to regions within the domain or not. For any region that contains a region in the domain, the containing region is also in the domain.

(+) Word delimiter: any of the characters (".:;/!&()+-=[]{}?<>|\), plus em dash and en dash, plus the comma if not immediately adjacent to two digits, plus the single quote if not immediately adjacent to two alphabetic (non-numeric, non-punctuation) characters, plus CR or LF, plus the start or end of a string. Dashes are intentionally word delimiters so that occurrences with and without dashes can be found equivalent.

(+) Word: A sequence of one more characters either beginning with an alphabetic character or else containing only digits (representing an integer), and bounded on each side within text by a word delimiter.

(+) Normalized word: A word latinized by removing all accents and diacritics, by converting to lowercase, and by deleting single quotes.

(+) Word series: A set of one or more consecutive words found in text excluding words of fewer than 3 characters and other specific words, normalized and then alphanumerically ordered. Words of fewer than 3 characters are ignored for purposes of determining whether words are consecutive, as are the following words: and, for, from, the, with.

(+) Phonetic code: The phonetic code of a word containing no digits is the phonetic encoding of the word, according to some phonetic encoding algorithm. The phonetic code of a word containing at least one digit is the exact word itself, preceded by a pound ('#'), assuming that the pound does not appear in any phonetic encoding. The phonetic code for any other word that the phonetic encoding algorithm cannot code is also the exact word preceded by a pound.

(+) Phonetic series: A set of one or more phonetic codes together corresponding to a word series, with each phonetic code being the phonetic code for its corresponding (normalized) word in the word series, ordered alphanumerically by phonetic code.

(+) Locality key: A storage key that is a hybrid of the ID for the most-specific geographic region associated with the locality and the locality ID.

## Persistent Data Structures

### AdjacentRegionsGraph

Indicates which geographic regions touch one another, associating regions by their Specify geographic IDs. This data structure could be kept in memory once read from storage, because it's not very large. In particular, this structure indicates:

(+) Adjacencies among U.S. counties.
(+) Adjacencies among U.S. counties and Mexican states.
(+) Adjacencies among U.S. counties and Canadian provinces.
(+) Adjacencies among U.S. states, Mexican states, and Canadian provinces.
(+) Adjacencies among North American countries.

The relationships that Specify provides also make it possible to navigate from county to state and from state or province to country. Each containing region is treated as adjacent to each of the regions it contains (and vice versa). And each region is considered adjacent to each region that contains an adjacent region (and vice versa).

For the remainder of this document, regions are considered "adjacent" when they are adjacent according to AdjacentRegionsGraph.

### CachedLocalitiesStore (C)

Cached preprocessed localities. Prior to use, localities must be preprocessed to produce their word series and phonetic series. This is a time-consuming process, so the results are cached to prevent having to repeat the process. The algorithm manages this structure to try to minimize the number of localities that are cached at any time, thereby reducing the amount of memory required.

The key is a locality key, allowing localities to be looked up or deleted as a group by specific geographic ID, and allowing individual localities to be retrieved. The value is the preprocessed locality (details TBD).

### PendingRegionsStore (P)

A list of all regions of the domain, at all levels of geographic rank, that have not yet been processed for consolidation. Serves as a to-do list for the consolidation algorithm. A region is removed from PendingRegionsStore when all of its localities have been processed for consolidation and the caches for these localities have been removed.

The key is the region's geographic ID. The value is the region's rank.

TODO: Examine whether it would be more efficient to store pending regions grouped by rank.

### RegionCacheStatusStore (W)

Indicates the status of locality caches for regions adjacent to each region currently undergoing processing. Used to select each next region to process in a way that minimizes the number of localities cached at any time while still allowing the user to evaluate one locality at a time before forever moving on to other localities. This structure should be small enough to be kept in memory for speed but mirrored to disk for recovery purposes.

The key is a geography ID for a region. The value is a structure containing the following information:

(+) inDomain: Whether the region is in the domain. If it is not in the domain, it is a region adjacent  to a region in the domain.
(+) isCached: Whether localities for the region have been cached. If the region has no localities, this indicates whether the localities would have been cached were there any.
(+) localityTotal: The number of localities in the region not also designated to a region that the region contains.
(+) adjacentUncachedCount: The total number of localities remaining to be cached in all adjacent regions. This value is only defined in cached regions but is always initialized to zero for the calculation algorithm.

When a region is added to RegionCacheStatusStore, it is added either cached or uncached. When adding a cached region of the domain, any region adjacent to it (whether in the domain or not) not already in RegionCacheStatusStore is also added uncached, taking care to keep each affected region's adjacentUncachedCount accurate. Likewise, when caching localities for any previously-uncached domain region of RegionCacheStatusStore, any region adjacent to the region not already in RegionCacheStatusStore is also added uncached, taking care to keep each affected region's adjacentUncachedCount accurate.

Define function setUncachedCounts(newlyCachedRegions):
	[Note: all newlyCachedRegions must have been previously added to RegionCacheStatusStore (W).]
	(+) For each region (N) in newlyCachedRegions:
		(+) If (N) is in the domain:
			(+) Add to RegionCacheStatusStore (W) all regions adjacent to (N) not already in RegionCacheStatusStore (W), adding them as uncached regions. 
		(+) Else:
			(+) Add to RegionCacheStatusStore (W) all regions simultaneously adjacent to (N), not already in RegionCacheStatusStore (W), and in the domain, adding them as uncached regions.
	(+) For each region (N) in newlyCachedRegions:
		(+) Add to (N)'s adjacentUncachedCount (initialy zero) the localityTotal of each uncached region adjacent to (N) found in RegionCacheStatusStore (W).

(There is a solution that keeps even fewer localities cached at a time, but it jumps around from region to region, preventing the user from focusing on evaluating one locality against all possible similar localities before moving on to the next locality. The present approach should help the user be more efficient, less error-prone, and less frustrated.)

### PhoneticLocalityIndex (Y)

Associates phonetic codes with cached localities whose phonetically-encoded text contains at least one instance of the phonetic code. Used to process groups of localities all sharing phonetic codes for possible presentation to the user to consider for consolidation.

They key is a phonetic code. The value is a list of locality keys.

When a cached locality is removed from the CachedLocalitiesStore (C), its locality keys are removed from all of its phonetic codes in PhoneticLocalityIndex. When a phonetic key loses all of its associated locality keys, the record is removed from PhoneticLocalityIndex, thus keeping the size of PhoneticLocalityIndex to the minimum needed.

### ExcludedMatchesStore (X)

Stores permanent knowledge about which pairs of word series having identical phonetic series are not to be considered suggestive of having duplicate localities.

The key is a word series. The value is a list of word series, possibly empty. If the key is found in two different localities, their common phonetic series will not be considered a match for purposes of presenting a potential duplicate to the user. Similarly, if the key is found in one locality and one of its value word series is found in another locality, their common phonetic series will not be considered a match for purposes of presenting a potential duplicate to the user.

Each value of each key K also appears as a key in ExcludedMatchesStore indicating that it is not a match for the word series given by key K.

## Storage Files

### LocalitySmarts

This is a data storage file stored in a preference-indicated directory and containing the following structures:

(+) CompletedAdjacenciesStore (X)

All users share this file.

### LocalityWork

This is a data storage file having a separate version stored in each user's directory and containing the following structures:

(+) CachedLocalitiesStore (C)
(+) PendingRegionsStore (P)
(+) RegionCacheStatusStore (W)
(+) PhoneticLocalityIndex (Y)

The file also indicates the domain selected for consolidation.

The file is deleted after consolidation completes.

## Initialization for the Consolidation Algorithm

(+) If the user's LocalityWork file does not yet exist:

	(+) Create the LocalityWork file and its data structures.
	(+) Add each geographic region of the selected domain to PendingRegionsStore (P). This only includes containing regions if the containing regions are themselves in the domain.
	(+) Set currentRegion (R) to an arbitrary region of PendingRegionsStore (P), selected from among the most specific regions available.
	(+) Cache the localities for currentRegion (R) in CachedLocalitiesStore (C).
	(+) Mark currentRegion (R) as cached in RegionCacheStatusStore (W), initializing its adjacentUncachedCount to zero.
	(+) Call RegionCacheStatusStore.setUncachedCounts([currentRegion (R)]).
	
(+) If the user's LocalityWork already exists:

	(+) Determine the lowest adjacentUncachedCount of any region in RegionCacheStatusStore (W).
	(+) Set currentRegion (R) to an arbitrary region of RegionCacheStatusStore (W), selected from among the cached regions having this lowest adjacentUncachedCount.

## Outer Processing Loop

[Note that currentRegion (R) must be a cached region of RegionCacheStatusStore (W).]

(+) Consolidate and remove the current region:
	(+) If currenRegion (R)'s adjacentUncachedCount is not zero:
		(+) If currentRegion (R) is in the domain:
			(+) Let toBeCachedRegions be a list of all uncached regions adjacent to currentRegion (R).
		(+) Else:
			(+) Let toBeCachedRegions be a list of all uncached in-domain regions adjacent to currentRegion (R).
		(+) If toBeCachedRegions is non-empty:
			(+) For each region (T) in toBeCachedRegions (necessarily also already in RegionCacheStatusStore (W)):
				(+) Cache (T)'s localities in CachedLocalitiesStore (C).
				(+) Mark (T) as cached in RegionCacheStatusStore (W).
				(+) Temporarily set (T)'s adjacentUncachedCount to zero.
				(+) For each cached region (A) adjacent to (T) in RegionCacheStatusStore (W):
					(+) Subtract (T)'s localityTotal from (A)'s adjacentUncachedCount.
					TODO: I think this oversubtracts.
			(+) Call RegionCacheStatusStore.setUncachedCounts(toBeCachedRegions).
	(+) Process currentRegion (R) according to the region processing algorithm.
	(+) Remove the localities cached for currentRegion (R).
	(+) Remove currentRegion (R) from RegionCacheStatusStore (W).
	(+) If currentRegion (R) is in the domain:
		(+) Remove currentRegion (R) from PendingRegionsStore (P).

(+) Select the next region to consolidate:
	(+) If PendingRegionsStore (P) is empty:
		(+) Set currentRegion (R) to end the loop.
	(+) Else:
		(+) Determine the lowest value of adjacentUncachedCount among the cached regions of RegionCacheStatusStore (W).
		(+) Set currentRegion (R) to an arbitrarily selected cached region of RegionCacheStatusStore (W) having this lowest value of adjacentUncachedCount.

(+) Repeat the loop if currentRegion (R) is not null.


 