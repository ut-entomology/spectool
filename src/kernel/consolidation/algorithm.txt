# Locality Consolidation Algorithm

## Important Notes

(+) Because multiple users on the same computer or across multiple computers could be simultaneously doing consolidations, I'll need to verify that associated data in Specify has not changed prior to modifying the database.

## Terminology

(+) Domain: The set of all geographic regions whose localities are all to be examined for consolidation with other localities, whether these other localities belong to regions within the domain or not. For any region that contains a region in the domain, the containing region is also in the domain.

(+) Word delimiter: any of the characters (".:;/!&()+-=[]{}?<>|\), plus em dash and en dash, plus the comma if not immediately adjacent to two digits, plus the single quote if not immediately adjacent to two alphabetic (non-numeric, non-punctuation) characters, plus CR or LF, plus the start or end of a string. Dashes are intentionally word delimiters so that occurrences with and without dashes can be found equivalent.

(+) Word: A sequence of one more characters either beginning with an alphabetic character or else containing only digits (representing an integer), and bounded on each side within text by a word delimiter.

(+) Normalized word: A word latinized by removing all accents and diacritics, by converting to lowercase, and by deleting single quotes.

(+) Word series: A set of one or more consecutive words found in text excluding words of fewer than 3 characters and other specific words, normalized and then alphanumerically ordered. Words of fewer than 3 characters are ignored for purposes of determining whether words are consecutive, as are the following words: and, for, from, the, with.

(+) Phonetic code: The phonetic code of a word containing no digits is the phonetic encoding of the word, according to some phonetic encoding algorithm. The phonetic code of a word containing at least one digit is the exact word itself, preceded by a pound ('#'), assuming that the pound does not appear in any phonetic encoding. The phonetic code for any other word that the phonetic encoding algorithm cannot code is also the exact word preceded by a pound.

(+) Phonetic series: A set of one or more phonetic codes together corresponding to a word series, with each phonetic code being the phonetic code for its corresponding (normalized) word in the word series, ordered alphanumerically by phonetic code.

(+) Locality key: A storage key that is a hybrid of the ID for the most-specific geographic region associated with the locality and the locality ID.

## Persistent Data Structures

### AdjacentRegionsGraph

Indicates which geographic regions touch one another, associating regions by their Specify geographic IDs. This data structure could be kept in memory once read from storage, because it's not very large. In particular, this structure indicates:

(+) Adjacencies among U.S. counties.
(+) Adjacencies among U.S. counties and Mexican states.
(+) Adjacencies among U.S. counties and Canadian provinces.
(+) Adjacencies among U.S. states, Mexican states, and Canadian provinces.
(+) Adjacencies among North American countries.

The relationships that Specify provides also make it possible to navigate from county to state and from state or province to country. Each containing region is treated as adjacent to each of the regions it contains (and vice versa). And each region is considered adjacent to each region that contains an adjacent region (and vice versa).

### CachedLocalitiesStore (C)

Cached preprocessed localities. Prior to use, localities must be preprocessed to produce their word series and phonetic series. This is a time-consuming process, so the results are cached to prevent having to repeat the process. The algorithm manages this structure to try to minimize the number of localities that are cached at any time, thereby reducing the amount of memory required.

The key is a locality key, allowing localities to be looked up or deleted as a group by specific geographic ID, and allowing individual localities to be retrieved. The value is the preprocessed locality (details TBD).

### PendingRegionsStore (P)

A list of all regions of the domain, at all levels of geographic rank, that have not yet been processed for consolidation. Serves as a to-do list for the consolidation algorithm. A region is removed from PendingRegionsStore when all of its localities have been processed for consolidation and the caches for these localities have been removed.

The key is the region's geographic ID. The value is the region's rank.

TODO: Examine whether it would be more efficient to store pending regions grouped by rank.

### RegionCacheStatusStore (W)

Indicates the status of locality caches for regions adjacent to each region currently undergoing processing. Used to select each next region to process in a way that minimizes the number of localities cached at any time. This structure should be small enough to be kept in memory for speed but mirrored to disk for recovery purposes.

The key is a geography ID for a region. The value is a structure containing the following information:

(+) inDomain: Whether the region is in the domain. If it is not in the domain, it is a region immediately adjacent (according to AdjacentRegionsGraph) to a region in the domain.
(+) isCached: Whether localities for the region have been cached. If the region has no localities, this indicates whether the localities would have been cached were there any.
(+) localityTotal: The number of localities in the region not also designated to a region that the region contains.
(+) adjacentUncachedCount: The total number of localities remaining to be cached in all adjacent regions (according to AdjacentRegionsGraph).

When a region is added to RegionCacheStatusStore, it is added either cached or uncached. When adding a cached region of the domain, any region adjacent to it (whether in the domain or not) not already in RegionCacheStatusStore is also added uncached, taking care to keep each affected region's adjacentUncachedCount accurate. Likewise, when caching localities for any previously-uncached domain region of RegionCacheStatusStore, any region adjacent to the region not already in RegionCacheStatusStore is also added uncached, taking care to keep each affected region's adjacentUncachedCount accurate.

### PhoneticLocalityIndex (Y)

Associates phonetic codes with cached localities whose phonetically-encoded text contains at least one instance of the phonetic code. Used to process groups of localities all sharing phonetic codes for possible presentation to the user to consider for consolidation.

They key is a phonetic code. The value is a list of locality keys.

When a cached locality is removed from the CachedLocalitiesStore (C), its locality keys are removed from all of its phonetic codes in PhoneticLocalityIndex. When a phonetic key loses all of its associated locality keys, the record is removed from PhoneticLocalityIndex, thus keeping the size of PhoneticLocalityIndex to the minimum needed.

### ExcludedMatchesStore (X)

Stores permanent knowledge about which pairs of word series having identical phonetic series are not to be considered suggestive of having duplicate localities.

The key is a word series. The value is a list of word series, possibly empty. If the key is found in two different localities, their common phonetic series will not be considered a match for purposes of presenting a potential duplicate to the user. Similarly, if the key is found in one locality and one of its value word series is found in another locality, their common phonetic series will not be considered a match for purposes of presenting a potential duplicate to the user.

Each value of each key K also appears as a key in ExcludedMatchesStore indicating that it is not a match for the word series given by key K.

## Storage Files

### LocalitySmarts

This is a data storage file stored in a preference-indicated directory and containing the following structures:

(+) CompletedAdjacenciesStore (X)

All users share this file.

### LocalityWork

This is a data storage file having a separate version stored in each user's directory and containing the following structures:

(+) CachedLocalitiesStore (C)
(+) PendingRegionsStore (P)
(+) RegionCacheStatusStore (W)
(+) PhoneticLocalityIndex (Y)

The file also indicates the domain selected for consolidation.

The file is deleted after consolidation completes.

## Initialization for the Consolidation Algorithm

(+) If the user's LocalityWork file does not yet exist:

	(+) Create the LocalityWork file and its data structures.
	(+) Add each geographic region of the selected domain to PendingRegionsStore (P), setting their states to 'pending'. This only includes containing regions if the containing regions are themselves in the domain.
	(+) Set currentRegion (R) to an arbitrary region of PendingRegionsStore (P), selected from among the most specific regions available.
	(+) Add currentRegion (R) to RegionCacheStatusStore (W), caching it, and add each adjacent region of currentRegion (according to AdjacentRegionsStore) to RegionCacheStatusStore (W), caching them too.
	
(+) If the user's LocalityWork already exists:

	(+) Determine the lowest adjacentUncachedCount of any region in RegionCacheStatusStore (W).
	(+) Set currentRegion (R) to an arbitrary region of RegionCacheStatusStore (W), selected from among the regions having this lowest adjacentUncachedCount.

## Outer Processing Loop

(+) Consolidate and remove the current region:
	(+) If currentRegion (R) is a domain region:
		(+) For each adjacent (A) region of currentRegion (R) (according to AdjacentRegionsStore):
			(+) If (A) is not already in RegionCacheStatusStore (W):
				(+) Add (A) to RegionCacheStatusStore (W), caching its localities in CachedLocalitiesStore (C).
		(+) 
		
		 Note that this also results in adding to RegionCacheStatusStore (W) any not-yet-present regions adjacent to those of these cached regions that are in the domain, adding them uncached, and it results in updating all affected adjacentUncachedCount values.
	(+) Process currentRegion (R) according to the region processing algorithm.
	(+) Remove the localities cached for currentRegion (R).
	(+) Remove currentRegion (R) from RegionCacheStatusStore (W).
	(+) Remove currentRegion (R) from PendingRegionsStore (P).

(+) Select the next region to consolidate:
	(+) Determine the set of regions adjacentInProgressRegions that are adjacent to currentRegion (according to AdjacentRegionsGraph) and in CompletedAdjacenciesStore (U).
	(+) If adjacentInProgressRegions is empty:
		(+) If RemainingAdjacenciesStore is empty:
			(+) Set currentRegion (R) to null (to end the loop).
		(+) Else:
			(+) Determine the lowest geographic rank of all regions remaining in CompletedAdjacenciesStore (U).
			(+) Determine the highest adjacency count among the regions of CompletedAdjacenciesStore (U) having this lowest rank.
			(+) Set currentRegion (R) to a region arbitrarily selected from the regions of CompletedAdjacenciesStore (U) having this lowest geographic rank and highest adjacency count.
			(TBD) How do I do the above efficiently?
	(+) Else:
		(+) For each region in adjacentInProgressRegions, increment the region's count in CompletedAdjacenciesStore (U).
		(+) Determine the lowest geographic rank among the regions in adjacentInProgressRegions.
		(+) Determine the highest count in CompletedAdjacenciesStore (U) of all regions in adjacentInProgressRegions having this lowest geographic rank.
		(+) Set currentRegion (R) to a region arbitrarily selected from the regions of adjacentInProgressRegions having this lowest geographic rank and highest count.
		(TBD) How do I do the above efficiently?

(+) Repeat the loop if currentRegion (R) is not null.


 